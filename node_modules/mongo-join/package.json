{
  "name": "mongo-join",
  "description": "mongo-join provides document joins for MongoDB in Node.js. Based on the node-mongodb-native module.",
  "author": {
    "name": "Chris Bumgardner",
    "email": "cbumgard@gmail.com"
  },
  "version": "1.0.0",
  "scripts": {
    "test": "mocha"
  },
  "main": "./lib/index",
  "repository": {
    "type": "git",
    "url": "https://github.com/cbumgard/node-mongo-join"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/cbumgard/node-mongo-join/blob/master/LICENSE"
    }
  ],
  "dependencies": {
    "mongodb": "1.2.x",
    "async": "0.1.x",
    "underscore": "1.4.x",
    "semaphore": "1.0.x"
  },
  "devDependencies": {
    "mocha": "1.7.x",
    "should": "1.2.x"
  },
  "engines": {
    "node": "0.8.x",
    "npm": "1.1.x"
  },
  "readme": "# mongo-join\n\n__mongo-join__ provides simple document joins for [MongoDB](http://www.mongodb.org/) in [Node.js](http://nodejs.org/). Based on the [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) module.\n\n## Why\n\nWhile building an ad-hoc reporting and export-to-csv library, I found myself doing repetitive 'join'-type queries to merge together documents across different collections. \n\n## Status\n\nThis is experimental currently. Much more testing (functional, integration, performance) needs to be added. It passes all initial proof-of-concept tests I have written. Performance has not yet been tackled, although I have ideas in this area. Currently a separate findOne() query is executed against each collection that is joined into the master document. *If you are interested I would love your help, especially for testing and performance optimizations!* Please send pull requests.\n\n## Goals\n\n- Integration with other mongo libraries for node, e.g. [mongoose](http://mongoosejs.com/) and [mongoskin](https://github.com/kissjs/node-mongoskin). Join depends solely on a node-mongodb-native Db client which hopefully will make that relatively easy.\n- Performance optimizations. One thought, say for toArray(), is to obtain cursors on the secondary collections and call toArray() on them, and join by iterating and mapping. This will be more memory intensive.\n\n## Installation\n\n```npm install mongo-join```\n\n## Example\n\nLet's say for example you have the following three collections:\n\n- employees: contains a reference to an employer (by ObjectID) and contact (by email)\n- employers: contains employer information\n- contacts: contains the employees contact info, including email\n\nYou want to query the employees and get back their employer and contact info. You'd like the employer document to replace the ObjectID that represents it in the employee document. You'd like the contact document to be added as a separate field in the employee document. Here is an example of that:\n\n```javascript\n\n    // Query an employees collection, whose documents contain fields\n    // referencing documents in the employer and contacts collections.\n    var Join = require('mongo-join').Join\n      , config = require('./config') // <- for example purposes\n      , mongodb = require('mongodb')\n      , Db = mongodb.Db\n      , Server = mongodb.Server;\n\n    var client = new Db(config.dbname, new Server(config.host, config.port));\n    client.open(function(err, client) {\n      client.collection('employees', function(err, employees) {\n        employees.find({}, function(err, cursor) {\n          var join = new Join(client).on({\n            field: 'employer', // <- field in employee doc\n            to: '_id',         // <- field in employer doc. treated as ObjectID automatically.\n            from: 'employers'  // <- collection name for employer doc\n          }).on({\n            field: 'contactEmail', // <- field in employee doc\n            as: 'contactInfo',     // <- new field in employee for contact doc\n            to: 'email',           // <- field in contact doc\n            from: 'contacts'       // <- collection name for contact doc\n          });          \n          join.toArray(cursor, function(err, joinedDocs) {\n            // handle array of joined documents here\n          });\n        });\n      });  \n    });\n```\n\n## Streaming\n\nIn the example above, instead of ```join.toArray()``` we would do:\n\n```javascript\n\n    var stream = join.stream(cursor);\n    stream.on('data', function(joinedDoc) {\n      // handle joined document here\n    });\n```\n\n## API\n\n### Constructor\n\nA new Join is constructed on a mongodb client. E.g. ```var join = new Join(client);```\n\n### on(opts)\n\nJoin instances are configured via the API method ```join.on(opts)```, which takes an opts object containing the following options describing how to join documents from secondary collections into the documents in the primary collection. The ```join.on(opts)``` method returns back the instance of the join so it can be chained. The opts object contains the following fields:\n\n    /**\n    * Add a new join on another collection.\n    * @param  {Object} opts Must contain fields 'field', 'to', and 'from', and\n    * optionally 'as'. \n    * 'field' specifies the field name in this cursor's doc\n    * that references a foreign collection's doc we want to join. \n    * 'to' represents the field name in the foreign collection's doc\n    * 'from' represents the name of the foreign collection. \n    * 'as' optionally specifies a new or existing field in this \n    * collection's doc that will hold the\n    * joined doc from the foreign collection. If 'as' is omitted, the joined\n    * doc by default will be stored in the 'field' field.\n    * 'id' optionally specifies (true or false) whether the 'to' field should be\n    * treated as a MongoDB ObjectID. By default true if 'to' is the field '_id'\n    * and false otherwise.\n    * @return {Join}   This instance. Can be used to chain .on() method calls.\n    */\n\n### findOne(collection, query, [opts], callback)\n\n    /**\n     * Performs join on calls to the specified collection's each() method.\n     * Like the Collection.each() method, this method takes a variable\n     * length of arguments. The first must be a Collection in this case, \n     * and the second must be a query object to find a single document,\n     * and the last must be a callback function that expects the \n     * form (err, joinedDoc).\n     * @param {Collection} collection Collection used to perform the findOne().\n     * @param {Object}     query      Query to find one document.\n     * @param {Object}     opts       (Optional) Options to the query.\n     * @param {Function}   callback   Callback after document is found and joined.\n     * Takes form (err, joinedDoc).\n     * @return {None}\n     */\n\n### nextObject(cursor, [opts], callback)\n\n    /**\n     * Performs join on calls to the specified cursor's nextObject() method.\n     * @param  {Cursor}   cursor  Cursor for a collection query.\n     * @param  {Object}   options (Optional) Options for nextObject().\n     * @param  {Function} fn      Callback. Passed in (err, joinedDoc).\n     * @return {None}\n     */\n\n### each(cursor, callback)\n\n    /**\n     * Performs join on calls to the specified cursor's each() method.\n     * @param  {Cursor}   cursor Cursor for a collection query.\n     * @param  {Function} fn     Callback takes the form (err, joinedDoc)\n     * @return {None}\n     */\n\n### toArray(cursor, callback)\n\n    /**\n     * Performs a join on calls to the specified cursor's toArray() method.\n     * @param  {Cursor}   cursor Cursor for a collection query.\n     * @param  {Function} fn     Callback takes the form (err, joinedDocAry).\n     * The second argument is an array of joined documents.\n     * @return {None}\n     */\n\n### stream(stream, event, callback)\n\n    /**\n     * Modifies a MongoDB native cursor stream so that documents from \n     * emitted 'data' type events will be joined based on the join criteria\n     * for this instance.\n     * @param  {Cursor} cursor Cursor for a collection query that will be streamed.\n     * @return {CursorStream} A CursorStream whose .on() method is proxied\n     * so that 'data' type events are captured and the emitted document\n     * is joined before resuming the stream.\n     */",
  "readmeFilename": "README.md",
  "_id": "mongo-join@1.0.0",
  "dist": {
    "shasum": "3cf3a6da70fe8a7d989e2c5c6c6328a7bbf8a773",
    "tarball": "http://registry.npmjs.org/mongo-join/-/mongo-join-1.0.0.tgz"
  },
  "_npmVersion": "1.1.71",
  "_npmUser": {
    "name": "cbumgard",
    "email": "cbumgard@gmail.com"
  },
  "maintainers": [
    {
      "name": "cbumgard",
      "email": "cbumgard@gmail.com"
    }
  ],
  "directories": {},
  "_shasum": "3cf3a6da70fe8a7d989e2c5c6c6328a7bbf8a773",
  "_from": "mongo-join@",
  "_resolved": "https://registry.npmjs.org/mongo-join/-/mongo-join-1.0.0.tgz"
}
